# Si se llaman "Gene Name" (con espacio), el c√≥digo usar√° comillas invertidas (`Gene Name`).
print("Columnas cargadas:")
print(colnames(annot_manual))
## 2. Procesar y consolidar las anotaciones
# ----------------------------------------------------------------
# Agrupamos por transcrito y juntamos todas sus anotaciones en una sola l√≠nea.
annot_procesado <- annot_manual %>%
group_by(`Transcript Name`) %>% # Agrupamos por el ID del transcrito
summarise(
# Juntamos todos los GO IDs √∫nicos, separados por "; "
GO_IDs = paste(unique(na.omit(`GO ID`)), collapse = "; "),
# Hacemos lo mismo con las descripciones funcionales
Descriptions = paste(unique(na.omit(Description)), collapse = " | ")
) %>%
ungroup() # Es buena pr√°ctica desagrupar al final
cat("\n‚úÖ Tabla de anotaciones procesada. Vista previa:\n")
print(head(annot_procesado))
## 3. Unir las anotaciones con tus datos originales
# ----------------------------------------------------------------
# Primero, con los datos de clusters
df_annotated_clusters <- df_clusters_h %>%
# Unimos usando el ID del gen/transcrito.
left_join(annot_procesado, by = c("GeneID" = "Transcript Name"))
# Segundo, con tu lista de genes invertidos
df_annotated_invertidos <- tibble(GeneID = genes_invertidos) %>%
left_join(annot_procesado, by = c("GeneID" = "Transcript Name"))
## 4. Verificaci√≥n y guardado final
# ----------------------------------------------------------------
cat("\nüìê Vista previa de los clusters anotados:\n")
# Usamos `glimpse` para ver todas las columnas de forma compacta
glimpse(df_annotated_clusters)
cat("\nüíæ Guardando resultados anotados...\n")
write_csv(df_annotated_clusters, here("salidas_data", "annotated_clusters.csv"))
write_csv(df_annotated_invertidos, here("salidas_data", "annotated_invertidos.csv"))
cat("¬°Proceso de anotaci√≥n completado con √©xito! ‚ú®\n")
# --- FIN DEL C√ìDIGO ---
# Filtra el data frame para ver solo las filas que S√ç tienen anotaciones
df_annotated_clusters %>%
filter(!is.na(GO_IDs))
# Esta tabla deber√≠a tener 40 filas y NO tener NAs (o muy pocos, si algunos genes no ten√≠an anotaci√≥n)
print(df_annotated_invertidos)
####################### 31-10-25
# =================================================================
# BLOQUE DE VERIFICACI√ìN DE DATOS (CHEQUEO DE SANIDAD)
# =================================================================
cat("ü§î Iniciando chequeo de integridad de los datos de entrada...\n\n")
# --- 1. Verificaci√≥n de 'df_annotated_clusters' ---
cat("üìä Verificando 'df_annotated_clusters'...\n")
glimpse(df_annotated_clusters)
genes_con_go_en_clusters <- sum(!is.na(df_annotated_clusters$GO_IDs) & df_annotated_clusters$GO_IDs != "")
cat(" -> Total de genes con anotaci√≥n GO en clusters:", genes_con_go_en_clusters, "\n\n")
# --- 2. Verificaci√≥n de 'df_annotated_invertidos' ---
cat("üìä Verificando 'df_annotated_invertidos'...\n")
glimpse(df_annotated_invertidos)
genes_con_go_en_invertidos <- sum(!is.na(df_annotated_invertidos$GO_IDs) & df_annotated_invertidos$GO_IDs != "")
cat(" -> Total de genes con anotaci√≥n GO en invertidos:", genes_con_go_en_invertidos, "\n\n")
# --- 3. Verificaci√≥n de 'genes_up_LPi' ---
cat("üìä Verificando 'genes_up_LPi'...\n")
cat(" -> Formato de los primeros IDs:", head(genes_up_LPi, 3), "\n")
cat(" -> N√∫mero total de genes en la lista 'up LPi':", length(genes_up_LPi), "\n")
# --- 4. Verificaci√≥n CR√çTICA: Cobertura del universo ---
# Creamos el universo de genes que S√ç tienen anotaci√≥n
universe <- unique(df_annotated_clusters$GeneID[!is.na(df_annotated_clusters$GO_IDs) & df_annotated_clusters$GO_IDs != ""])
cat(" -> Tama√±o del universo (genes con GO):", length(universe), "\n")
# Comprobamos cu√°ntos de nuestros genes de inter√©s est√°n en el universo
genes_up_LPi_en_universo <- sum(genes_up_LPi %in% universe)
cat(" -> De los", length(genes_up_LPi), "genes 'up LPi',", genes_up_LPi_en_universo, "est√°n en el universo y pueden ser analizados.\n\n")
cat("‚úÖ Chequeo de sanidad completado. Los datos parecen estar en orden.\n")
cat("=================================================================\n\n")
# --- El resto de tu script de enriquecimiento comenzar√≠a aqu√≠ ---
##########################COTINUACION DEL CODIGO
####Importante descargar la siguiente libreria
#if (!requireNamespace("BiocManager", quietly = TRUE))
# install.packages("BiocManager")
#BiocManager::install("org.At.thaliana.eg.db")
######################
# scripts/09_enrich_go_kegg.R (Versi√≥n Corregida)
# Objetivo: Enriquecer GO en subconjuntos usando anotaciones personalizadas.
#library(tidyverse)
#library(here)
#library(clusterProfiler)
# --- 1. Cargar y Preparar Datos de Anotaci√≥n Personalizados ---
# Cargar el archivo con TODAS las anotaciones GO para P. vulgaris
all_go_annotations <- read_csv(here("datos", "pvulgaris_all_go_annotations.csv"))
# Crear el archivo TERM2GENE: relaciona cada GO ID con su gen
# Esta es la base de datos para el enriquecimiento
# Crear el archivo TERM2GENE: relaciona cada GO ID con su gen
# Esta es la base de datos para el enriquecimiento
term2gene <- all_go_annotations %>%
# Explicitamente le decimos a R que use la funci√≥n select() del paquete dplyr
dplyr::select(term = `GO ID`, gene = `Transcript Name`) %>%
dplyr::filter(!is.na(term) & !is.na(gene)) %>%
dplyr::distinct() # Nos aseguramos de que no haya filas duplicadas
cat(" -> Se cre√≥ el mapa TERM2GENE con", nrow(term2gene), "asociaciones.\n")
# (Opcional pero recomendado) Crear archivo TERM2NAME para tener descripciones legibles
# NOTA: Para esto necesitar√°s la base de datos de GO. La instalamos si no est√°.
if (!requireNamespace("GO.db", quietly = TRUE)) {
BiocManager::install("GO.db")
}
library(GO.db)
# Aqu√≠ especificamos que queremos usar la funci√≥n select() del paquete dplyr
term2name <- as.data.frame(AnnotationDbi::select(GO.db, keys(GO.db), "TERM")) %>%
dplyr::select(term = GOID, name = TERM)
cat(" -> Se carg√≥ el mapa TERM2NAME con", nrow(term2name), "descripciones de GO.\n\n")
# --- 2. Cargar tus listas de genes de inter√©s ---
df_annotated_clusters <- read_csv(here("salidas_data", "annotated_clusters.csv"))
venn_list <- readRDS(here("salidas_data", "venn_lists.rds"))
genes_up_LPi <- venn_list$LPi
genes_invertidos <- df_annotated_invertidos$GeneID
# --- 3. Realizar el An√°lisis de Enriquecimiento con enricher() ---
# Definir el universo: TODOS los genes que tienen al menos una anotaci√≥n GO
universe <- unique(term2gene$gene)
cat(" -> Tama√±o del universo corregido:", length(universe), "genes.\n")
# Enriquecimiento para los genes invertidos
enrich_invertidos <- enricher(
gene = genes_invertidos,
universe = universe,
TERM2GENE = term2gene,
TERM2NAME = term2name,
pvalueCutoff = 0.05,
qvalueCutoff = 0.1
)
# Enriquecimiento para los genes 'up LPi'
enrich_up_LPi <- enricher(
gene = genes_up_LPi,
universe = universe,
TERM2GENE = term2gene,
TERM2NAME = term2name,
pvalueCutoff = 0.05,
qvalueCutoff = 0.1
)
# --- 4. Visualizar y Guardar Resultados ---
cat("\nüìä Resultados de enriquecimiento para genes invertidos:\n")
print(as.data.frame(enrich_invertidos))
# Crear un dotplot si hay resultados significativos
if (nrow(as.data.frame(enrich_invertidos)) > 0) {
dotplot(enrich_invertidos, showCategory = 15) + ggtitle("GO Enrichment - Genes Invertidos")
ggsave(here("salidas", "dotplot_invertidos.png"))
} else {
cat(" -> No se encontraron t√©rminos enriquecidos para los genes invertidos.\n")
}
write_csv(as.data.frame(enrich_invertidos), here("salidas_data", "enrich_go_invertidos.csv"))
cat("‚úÖ Proceso de enriquecimiento completado.\n")
#################################
##REVISION DE LOS DATOS
# Revisa los resultados de tu lista de genes m√°s grande
cat("\nüìä Resultados de enriquecimiento para genes 'up LPi':\n")
print(as.data.frame(enrich_up_LPi))
# Y visual√≠zalos si hay resultados
if (nrow(as.data.frame(enrich_up_LPi)) > 0) {
dotplot(enrich_up_LPi, showCategory = 15) + ggtitle("GO Enrichment - Genes Up LPi")
ggsave(here("salidas", "dotplot_up_LPi.png"))
} else {
cat(" -> No se encontraron t√©rminos enriquecidos para los genes 'up LPi'.\n")
}
############################
# --- 5. Enriquecimiento por Cluster (EL M√âTODO CORRECTO) ---
# Creamos una lista para guardar los resultados de cada cluster
enrich_clusters <- list()
# Hacemos un bucle que recorre cada n√∫mero de cluster (del 1 al 5)
for (clust_num in unique(df_annotated_clusters$cluster_h)) {
cat("\nAnalizando enriquecimiento para el Cluster", clust_num, "...\n")
# Extraemos los genes que pertenecen a este cluster
genes_del_cluster <- df_annotated_clusters %>%
filter(cluster_h == clust_num) %>%
pull(GeneID)
# Realizamos el enriquecimiento para la lista de genes de este cluster
resultado_enrich <- enricher(
gene = genes_del_cluster,
universe = universe,
TERM2GENE = term2gene,
TERM2NAME = term2name,
pvalueCutoff = 0.05,
qvalueCutoff = 0.1
)
# Guardamos el resultado en nuestra lista
enrich_clusters[[paste0("cluster_", clust_num)]] <- resultado_enrich
}
# Ahora puedes ver los resultados de un cluster espec√≠fico, por ejemplo, el cluster 2
cat("\nüìä Resultados para el Cluster 2:\n")
print(as.data.frame(enrich_clusters$cluster_2))
#### hasta este punto el script sirve perfectamente
# Imprime la tabla de resultados para el Cluster 3
print(as.data.frame(enrich_clusters$cluster_3))
# Crea un gr√°fico si hay resultados
if (nrow(as.data.frame(enrich_clusters$cluster_3)) > 0) {
dotplot(enrich_clusters$cluster_3) + ggtitle("GO Enrichment - Cluster 3")
}
###################################asta este punto todo funciona correctamente
# --- 6. Guardar Tablas y Gr√°ficos para CADA Cluster ---
cat("\nüíæ Iniciando el guardado de resultados por cluster...\n")
# Hacemos un bucle que recorre cada resultado en la lista 'enrich_clusters'
# names(enrich_clusters) nos da los nombres: "cluster_1", "cluster_2", etc.
for (nombre_cluster in names(enrich_clusters)) {
# Extraemos el resultado de enriquecimiento para el cluster actual
resultado_actual <- enrich_clusters[[nombre_cluster]]
# Convertimos el resultado a una tabla (data frame)
tabla_resultados <- as.data.frame(resultado_actual)
cat(" -> Procesando", nombre_cluster, "...\n")
# Verificamos si la tabla tiene resultados antes de intentar guardarla
if (nrow(tabla_resultados) > 0) {
# 1. GUARDAR LA TABLA COMO ARCHIVO CSV
# ------------------------------------
# Creamos un nombre de archivo din√°mico, ej: "enrich_go_cluster_1.csv"
nombre_archivo_csv <- here("salidas_data", paste0("enrich_go_", nombre_cluster, ".csv"))
write_csv(tabla_resultados, nombre_archivo_csv)
cat("    -> Tabla guardada en:", nombre_archivo_csv, "\n")
# 2. CREAR Y GUARDAR EL GR√ÅFICO DOTPLOT
# ------------------------------------
# Creamos un nombre de archivo din√°mico, ej: "dotplot_cluster_1.png"
nombre_archivo_png <- here("salidas", paste0("dotplot_", nombre_cluster, ".png"))
# Creamos el gr√°fico
grafico <- dotplot(resultado_actual, showCategory = 15) +
ggtitle(paste("GO Enrichment -", gsub("_", " ", nombre_cluster))) # T√≠tulo bonito
# Guardamos el gr√°fico
ggsave(nombre_archivo_png, plot = grafico, width = 8, height = 6)
cat("    -> Gr√°fico guardado en:", nombre_archivo_png, "\n")
} else {
# Si no hay resultados, simplemente lo informamos
cat("    -> Sin resultados de enriquecimiento significativos para este cluster.\n")
}
}
cat("\n‚úÖ ¬°Proceso de guardado completado para todos los clusters!\n")
#######################asta este punto todo funciona correctamente
# --- 7. (Opcional) Crear una Tabla Maestra con TODOS los resultados ---
# Usamos la funci√≥n `bind_rows` para unir todas las tablas de la lista en una sola.
# El argumento .id = "cluster" crea una nueva columna que nos dice de qu√© cluster vino cada fila.
# Usamos map() para convertir cada enrichResult en un data.frame PRIMERO.
# Luego, el resultado (una lista de data.frames) se pasa a bind_rows().
tabla_maestra_clusters <- purrr::map(enrich_clusters, as.data.frame) %>%
bind_rows(.id = "cluster")
# Verificamos c√≥mo se ve la tabla maestra
cat("\nüìä Vista previa de la tabla maestra combinada:\n")
glimpse(tabla_maestra_clusters)
# Guardamos esta tabla maestra en un solo archivo CSV
write_csv(tabla_maestra_clusters, here("salidas_data", "enrich_go_TODOS_LOS_CLUSTERS.csv"))
cat("\n‚úÖ Tabla maestra guardada exitosamente.\n")
############################3 hasta este punto sirve el el script
######################## a partir de aqui 1-11-2025
#install.packages("zoo") Es necesario para que sirva este script
# scripts/10_cruce_anotaciones.R
# Objetivo: Limpiar la tabla de genes simbi√≥ticos (S2) y cruzarla con nuestros resultados de enriquecimiento.
#library(janitor) # Muy √∫til para limpiar nombres de columnas
# --- 1. Cargar los datos que vamos a usar ---
# Tus resultados de enriquecimiento de todos los clusters
tabla_maestra_clusters <- read_csv(here("salidas_data", "enrich_go_TODOS_LOS_CLUSTERS.csv")) %>%
as_tibble()
tab_s2_cruda <- read_csv(here("datos", "tab_s2_early_signaling.csv"), col_names = FALSE)
#############################################
tab_s2_cruda <- read_csv(here("datos", "tab_s2_early_signaling.csv"), col_names = FALSE)
tab_s2_cruda <- as_tibble(tab_s2_cruda)  # Forzamos que sea un tibble
cat("Iniciando la limpieza de la Tabla S2 (versi√≥n CSV)...\n")
tab_s2_limpia <- read_csv(
here("datos", "tab_s2_early_signaling.csv"),
col_names = FALSE,
skip = 2
) %>%
row_to_names(row_number = 1) %>%
clean_names() %>%
mutate(across(everything(), as.character)) %>%
mutate(
across(contains("log2fc"), as.numeric),
across(contains("padj"), as.numeric)
)
cat("Tabla S2 limpiada correctamente.\n")
cat("Filas:", nrow(tab_s2_limpia), "| Columnas:", ncol(tab_s2_limpia), "\n")
print(head(tab_s2_limpia))
# Guardar la tabla limpia en la carpeta "salidas_data" (o donde quieras)
write_csv(
tab_s2_limpia,
here("salidas_data", "tab_s2_early_signaling_limpia.csv")
)
cat("Tabla S2 limpia guardada en: salidas_data/tab_s2_early_signaling_limpia.csv\n")
###################3hasta aqui todo funciono bien
#library(readr)
#library(dplyr)      # ‚Üê Carga dplyr
#library(tidyr)      # ‚Üê Carga tidyr
#library(stringr)    # ‚Üê Carga stringr
#library(here)
#library(janitor)
cat("Iniciando cruce final...\n")
# --- CARGAR Y CONVERTIR ---
tab_s2_limpia <- read_csv(here("salidas_data", "tab_s2_early_signaling_limpia.csv")) %>%
as_tibble()
tabla_maestra_clusters <- read_csv(here("salidas_data", "enrich_go_TODOS_LOS_CLUSTERS.csv")) %>%
as_tibble()
# --- EXPANDIR geneID (con dplyr:: expl√≠cito) ---
clusters_expandido <- tabla_maestra_clusters %>%
dplyr::select(cluster, ID, Description, RichFactor, FoldEnrichment, p.adjust, geneID) %>%
tidyr::separate_rows(geneID, sep = "/") %>%
dplyr::rename(id_raw = geneID) %>%
dplyr::mutate(
id_clean = stringr::str_remove(id_raw, "\\.\\d+$") %>% stringr::str_trim()
)
# --- LIMPIAR IDs en S2 ---
tab_s2_limpia <- tab_s2_limpia %>%
dplyr::mutate(
id_clean = stringr::str_remove(id, "\\.\\d+$") %>% stringr::str_trim()
)
# --- CRUCE ---
cruce_final <- tab_s2_limpia %>%
dplyr::left_join(clusters_expandido, by = "id_clean") %>%
dplyr::select(-id_raw, -id_clean)
# --- GUARDAR ---
ruta_final <- here("salidas_data", "cruce_S2_con_clusters_ENRIQUECIDO.csv")
write_csv(cruce_final, ruta_final)
cat("¬°CRUCE COMPLETADO!\n")
cat("Archivo guardado en:", ruta_final, "\n")
cat("Genes de S2 con GO asignado:", sum(!is.na(cruce_final$cluster)), "de", nrow(tab_s2_limpia), "\n")
########################### hasta aqui sirve el codigo
# --- SOLUCI√ìN: Usa dplyr:: ---
genes_con_go <- cruce_final %>%
dplyr::filter(!is.na(cluster)) %>%
dplyr::select(name, id, cluster, Description, p.adjust) %>%
dplyr::arrange(p.adjust)
# Ver resultado
print(genes_con_go)
# Guardar
write_csv(genes_con_go, here("salidas_data", "genes_S2_en_GO_enriquecido.csv"))
############################## hasta aqui todo bien
#library(ggplot2)
#library(dplyr)
# Contar genes por cluster
resumen <- genes_con_go %>%
count(cluster, name = "n_genes") %>%
mutate(cluster = factor(cluster, levels = c("cluster_1", "cluster_5")))
# Gr√°fico
ggplot(resumen, aes(x = cluster, y = n_genes, fill = cluster)) +
geom_col(width = 0.6, alpha = 0.9) +
geom_text(aes(label = n_genes), vjust = -0.5, size = 5, fontface = "bold") +
scale_fill_manual(values = c("cluster_1" = "#1f78b4", "cluster_5" = "#33a02c")) +
labs(
title = "Genes simbiontes en clusters enriquecidos (GO)",
subtitle = "16 de 194 genes (8.2%)",
x = "M√≥dulo de coexpresi√≥n",
y = "N√∫mero de genes simbiontes",
caption = "p.adjust < 0.05"
) +
theme_minimal(base_size = 14) +
theme(
legend.position = "none",
plot.title = element_text(face = "bold"),
axis.title = element_text(face = "bold")
)
ggsave(here("salidas_data", "FIG_genes_simbiontes_en_clusters.png"),
width = 7, height = 6, dpi = 300, bg = "white")
#################### bien todo bien
# Tabla bonita para paper
tabla_suplemento <- genes_con_go %>%
distinct(name, id, .keep_all = TRUE) %>%
select(name, id, cluster, Description, p.adjust) %>%
arrange(cluster, p.adjust)
write_csv(tabla_suplemento, here("salidas_data", "Tabla_S2_genes_enriquecidos.csv"))
# Ejemplo: Log2FC de los 16 genes en cada contraste
expr_16 <- cruce_final %>%
filter(!is.na(cluster)) %>%
select(name, id, contains("log2fc")) %>%
distinct(name, .keep_all = TRUE) %>%
pivot_longer(cols = starts_with("log2fc"), names_to = "contraste", values_to = "log2fc") %>%
mutate(contraste = case_when(
contraste == "log2fc" ~ "PHR-L7OX vs EV (-Pi)",
contraste == "log2fc_2" ~ "PHR-L7OX vs EV (+Pi)",
contraste == "log2fc_3" ~ "PHR-L7RNAi vs EV (-Pi)",
TRUE ~ contraste
))
# Heatmap
library(pheatmap)
pheatmap(
expr_16 %>% pivot_wider(names_from = contraste, values_from = log2fc) %>% column_to_rownames("name"),
scale = "row",
main = "Expresi√≥n de 16 genes simbiontes bajo PHR-L7"
)
View(expr_16)
View(duplicados)
View(enrich_clusters)
View(tabla_suplemento)
# 1. Asegurarse de que log2fc es num√©rico
expr_16_clean <- cruce_final %>%
filter(!is.na(cluster)) %>%
select(name, id, contains("log2fc")) %>%
distinct(name, .keep_all = TRUE) %>%
mutate(across(starts_with("log2fc"), as.numeric)) %>%  # ‚Üê FORZAR NUM√âRICO
pivot_longer(cols = starts_with("log2fc"), names_to = "contraste", values_to = "log2fc") %>%
mutate(contraste = case_when(
contraste == "log2fc" ~ "PHR-L7OX vs EV (-Pi)",
contraste == "log2fc_2" ~ "PHR-L7OX vs EV (+Pi)",
contraste == "log2fc_3" ~ "PHR-L7RNAi vs EV (-Pi)",
TRUE ~ contraste
)) %>%
drop_na(log2fc)  # ‚Üê ELIMINAR NA
# 2. Pivot wider con valores num√©ricos
mat_heatmap <- expr_16_clean %>%
pivot_wider(names_from = contraste, values_from = log2fc) %>%
column_to_rownames("name") %>%
as.matrix()  # ‚Üê CONVERTIR A MATRIZ NUM√âRICA
# 3. Heatmap (AHORA S√ç FUNCIONA)
pheatmap(
mat_heatmap,
scale = "row",
cluster_rows = TRUE,
cluster_cols = TRUE,
main = "16 genes simbiontes: regulaci√≥n por PvPHR-L7",
fontsize_row = 8,
color = colorRampPalette(c("blue", "white", "red"))(50)
)
warnings()
# 1. Verifica que TODAS las columnas de log2fc sean num√©ricas
str(mat_heatmap)
# 2. Busca NA o no-num√©ricos
any(is.na(mat_heatmap))
sapply(mat_heatmap, class)
# 3. Muestra filas problem√°ticas
which(is.na(mat_heatmap), arr.ind = TRUE)
# === CORREGIDO: FORZAR NUM√âRICO + ELIMINAR NA + VERIFICAR ===
expr_16_clean <- cruce_final %>%
filter(!is.na(cluster)) %>%
select(name, id, contains("log2fc")) %>%
distinct(name, .keep_all = TRUE) %>%
# FORZAR TODAS las columnas log2fc a num√©rico
mutate(across(starts_with("log2fc"), ~ as.numeric(as.character(.)))) %>%
# ELIMINAR filas con NA en log2fc
drop_na(starts_with("log2fc")) %>%
pivot_longer(cols = starts_with("log2fc"), names_to = "contraste", values_to = "log2fc") %>%
mutate(contraste = case_when(
contraste == "log2fc" ~ "PHR-L7OX vs EV (-Pi)",
contraste == "log2fc_2" ~ "PHR-L7OX vs EV (+Pi)",
contraste == "log2fc_3" ~ "PHR-L7RNAi vs EV (-Pi)",
TRUE ~ contraste
))
# === CREAR MATRIZ LIMPIA ===
mat_heatmap <- expr_16_clean %>%
pivot_wider(names_from = contraste, values_from = log2fc) %>%
column_to_rownames("name") %>%
as.matrix()
# === VERIFICAR QUE SEA NUM√âRICA ===
stopifnot(is.numeric(mat_heatmap))  # Si falla, hay problema
# === PASO CORRECTO: EXCLUIR 'id' DEL PIVOT ===
expr_16_clean <- cruce_final %>%
filter(!is.na(cluster)) %>%
select(name, contains("log2fc")) %>%        # ‚Üê ¬°SIN 'id'!
distinct(name, .keep_all = TRUE) %>%
mutate(across(starts_with("log2fc"), ~ as.numeric(as.character(.)))) %>%
drop_na(starts_with("log2fc")) %>%
pivot_longer(cols = starts_with("log2fc"), names_to = "contraste", values_to = "log2fc") %>%
mutate(contraste = case_when(
contraste == "log2fc" ~ "PHR-L7OX vs EV (-Pi)",
contraste == "log2fc_2" ~ "PHR-L7OX vs EV (+Pi)",
contraste == "log2fc_3" ~ "PHR-L7RNAi vs EV (-Pi)",
TRUE ~ contraste
))
# === MATRIZ FINAL (SOLO name + log2fc) ===
mat_heatmap <- expr_16_clean %>%
pivot_wider(names_from = contraste, values_from = log2fc) %>%
column_to_rownames("name") %>%
as.matrix()
# === VERIFICACI√ìN ===
str(mat_heatmap)  # ‚Üí num [1:16, 1:3]
stopifnot(is.numeric(mat_heatmap))
stopifnot(!any(is.na(mat_heatmap)))
# === HEATMAP FINAL ===
pheatmap(
mat_heatmap,
scale = "row",
cluster_rows = TRUE,
cluster_cols = TRUE,
main = "16 genes simbiontes regulados por PvPHR-L7",
fontsize_row = 9,
color = colorRampPalette(c("#2166AC", "white", "#B2182B"))(50),
border_color = "grey70"
)
ggsave("salidas/heatmap_16_genes_simbiontes.png", width = 8, height = 6, dpi = 300, bg = "white")
# Ver algunos IDs limpios de cada tabla
cat("=== IDs en S2 (limpios) ===\n")
print(head(tab_s2_limpia$id_clean, 10))
cat("\n=== IDs en GO (limpios) ===\n")
print(head(clusters_expandido$id_clean, 10))
# ¬øHay intersecci√≥n?
interseccion <- intersect(tab_s2_limpia$id_clean, clusters_expandido$id_clean)
# === VERIFICAR IDs ===
cat("=== IDs en S2 (limpios) ===\n")
print(head(tab_s2_limpia$id_clean, 10))
cat("\n=== IDs en GO (limpios) ===\n")
print(head(clusters_expandido$id_clean, 10))
# === INTERSECCI√ìN (USANDO base::intersect) ===
interseccion <- base::intersect(tab_s2_limpia$id_clean, clusters_expandido$id_clean)
cat("\n=== GENES SIMBIONTES EN CLUSTERS ENRIQUECIDOS ===\n")
cat("Total:", length(interseccion), "genes\n")
print(interseccion)
# === GUARDAR RESULTADO ===
write_lines(interseccion, here("salidas_data", "genes_simbiontes_en_GO.txt"))
source("instalar_paquetes.R")  # Ajusta la ruta si est√° en una subcarpeta
instalar_y_cargar(
paquetes_cran = c("fs", "here", "tidyverse", "data.table", "pheatmap", "writexl", "readxl", "skimr", "ggvenn", "factoextra", "stats","corrplot", "DataExplorer", "janitor", "stringr", "tidyr", "readr", "ggplot2", "conflicted"),
paquetes_bioc = c("biomartr", "clusterProfiler", "TSSr")
)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# Actualiza Bioconductor
BiocManager::install(version = "devel")  # O "release" para la versi√≥n estable
BiocManager::install("TSSr", dependencies = TRUE)
library(TSSr)
library(TSSr)
if (!require("devtools", quietly = TRUE))
install.packages("devtools")
devtools::install_github("BioinfoX/TSSr")
R.version.string
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# Usa la versi√≥n CORRECTA para R 4.5
BiocManager::install(version = "3.22")
# Forzar actualizaci√≥n de S4Vectors y paquetes base de Bioconductor
BiocManager::install(c("S4Vectors", "IRanges", "GenomicRanges", "GenomeInfoDb", "Seqinfo"), force = TRUE)
